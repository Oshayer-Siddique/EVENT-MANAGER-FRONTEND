package com.oshayer.event_manager.events.controller;

import com.oshayer.event_manager.events.dto.CreateEventRequest;
import com.oshayer.event_manager.events.dto.EventResponse;
import com.oshayer.event_manager.events.dto.UpdateEventRequest;
import com.oshayer.event_manager.events.service.EventService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.UUID;

@RestController
@RequestMapping("/api/events")
@RequiredArgsConstructor
public class EventController {

    private final EventService eventService;

    // CREATE
    @PostMapping
    public ResponseEntity<EventResponse> create(@Valid @RequestBody CreateEventRequest req) {
        EventResponse created = eventService.create(req);
        return ResponseEntity
                .created(URI.create("/api/events/" + created.getId()))
                .body(created);
    }

    // GET (by id)
    @GetMapping("/{id}")
    public ResponseEntity<EventResponse> get(@PathVariable UUID id) {
        return ResponseEntity.ok(eventService.get(id));
    }

    // LIST (paged)
    @GetMapping
    public ResponseEntity<Page<EventResponse>> list(
            @PageableDefault(size = 20, sort = "eventStart") Pageable pageable) {
        return ResponseEntity.ok(eventService.list(pageable));
    }

    // UPDATE (full/partial via PUT – your UpdateEventRequest is partial-friendly)
    @PutMapping("/{id}")
    public ResponseEntity<EventResponse> update(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateEventRequest req) {
        return ResponseEntity.ok(eventService.update(id, req));
    }

    // DELETE
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        eventService.delete(id);
        return ResponseEntity.noContent().build();
    }
}

package com.oshayer.event_manager.ticketing.controller;

import com.oshayer.event_manager.ticketing.dto.*;
import com.oshayer.event_manager.ticketing.service.TicketService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;

@RestController
@RequestMapping("/api/tickets")
@RequiredArgsConstructor
public class TicketController {

    private final TicketService ticketService;

    @PostMapping("/reserve")
    public ResponseEntity<TicketResponse> reserve(@Valid @RequestBody TicketCreateRequest req) {
        return ResponseEntity.ok(ticketService.createPending(req));
    }

    @PostMapping("/issue/{ticketId}")
    public ResponseEntity<TicketResponse> issue(@PathVariable java.util.UUID ticketId) {
        return ResponseEntity.ok(ticketService.issue(ticketId));
    }

    @PostMapping("/checkin/{ticketId}")
    public ResponseEntity<TicketResponse> checkIn(@PathVariable java.util.UUID ticketId,
                                                  @Valid @RequestBody TicketCheckInRequest req) {
        return ResponseEntity.ok(ticketService.checkIn(ticketId, req));
    }

    @PostMapping("/refund/{ticketId}")
    public ResponseEntity<TicketResponse> refund(@PathVariable java.util.UUID ticketId,
                                                 @Valid @RequestBody TicketRefundRequest req) {
        return ResponseEntity.ok(ticketService.refund(ticketId, req));
    }

    @GetMapping("/{ticketId}")
    public ResponseEntity<TicketResponse> get(@PathVariable java.util.UUID ticketId) {
        return ResponseEntity.ok(ticketService.get(ticketId));
    }

    @GetMapping
    public ResponseEntity<List<TicketResponse>> listTickets(
            @RequestParam(required = false) UUID eventId,
            @RequestParam(required = false) UUID buyerId
    ) {
        if (eventId != null) {
            return ResponseEntity.ok(ticketService.listByEvent(eventId));
        }
        if (buyerId != null) {
            return ResponseEntity.ok(ticketService.listByBuyer(buyerId));
        }
        // Consider returning a 400 Bad Request if no filter is provided, or defaulting to all tickets if that's desired.
        return ResponseEntity.ok(Collections.emptyList());
    }
}

package com.oshayer.event_manager.ticketing.controller;

import com.oshayer.event_manager.ticketing.dto.*;
import com.oshayer.event_manager.ticketing.service.ReservationHoldService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;

@RestController
@RequestMapping("/api/holds")
@RequiredArgsConstructor
public class ReservationHoldController {

    private final ReservationHoldService holdService;

    @PostMapping
    public ResponseEntity<HoldResponse> create(@Valid @RequestBody HoldCreateRequest req) {
        return ResponseEntity.ok(holdService.create(req));
    }

    @PostMapping("/release")
    public ResponseEntity<HoldResponse> release(@Valid @RequestBody HoldReleaseRequest req) {
        return ResponseEntity.ok(holdService.release(req));
    }

    @PostMapping("/convert")
    public ResponseEntity<HoldResponse> convert(@Valid @RequestBody HoldConvertRequest req) {
        return ResponseEntity.ok(holdService.convert(req));
    }

    @GetMapping("/{holdId}")
    public ResponseEntity<HoldResponse> get(@PathVariable java.util.UUID holdId) {
        return ResponseEntity.ok(holdService.get(holdId));
    }

    @GetMapping("/events/{eventId}")
    public ResponseEntity<List<HoldResponse>> listActive(@PathVariable java.util.UUID eventId) {
        return ResponseEntity.ok(holdService.listActive(eventId));
    }
}


package com.oshayer.event_manager.events.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class CreateEventRequest {

    // Identity & schedule
    @NotBlank private String typeCode;
    @NotBlank private String typeName;
    @NotBlank private String eventCode;
    @NotBlank private String eventName;
    @NotNull private ZonedDateTime eventStart;
    @NotNull private ZonedDateTime eventEnd;

    // Venue & layout
    @NotNull private UUID venueId;
    private UUID seatLayoutId; // optional

    // Staffing
    @NotNull private UUID eventManager;
    @NotNull private UUID eventOperator1;
    private UUID eventOperator2;
    @NotNull private UUID eventChecker1;
    private UUID eventChecker2;

    private List<String> imageUrls;

    private List<CreateEventTicketTierRequest> ticketTiers;

    // Optional associations
    private List<UUID> artistIds;
    private List<UUID> sponsorIds;
    private List<UUID> organizerIds;


}


package com.oshayer.event_manager.events.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class CreateEventTicketTierRequest {
    @NotBlank private String tierCode;
    @NotBlank private String tierName;
    @NotNull @PositiveOrZero private Integer totalQuantity;
    @NotNull @DecimalMin(value = "0.0", inclusive = true) private BigDecimal price;
}


package com.oshayer.event_manager.events.dto;

import lombok.*;
import java.math.BigDecimal;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class EventResponse {
    private UUID id;

    private String typeCode;
    private String typeName;
    private String eventCode;
    private String eventName;
    private ZonedDateTime eventStart;
    private ZonedDateTime eventEnd;

    private UUID venueId;
    private UUID seatLayoutId;

    private UUID eventManager;
    private UUID eventOperator1;
    private UUID eventOperator2;
    private UUID eventChecker1;
    private UUID eventChecker2;

    private List<UUID> organizerIds;
    private List<String> imageUrls;

    private List<EventTicketTierResponse> ticketTiers;

    private List<UUID> artistIds;
    private List<UUID> sponsorIds;

}



package com.oshayer.event_manager.events.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class EventTicketTierResponse {
    private UUID id;
    private String tierCode;
    private String tierName;
    private Integer totalQuantity;
    private BigDecimal price;
    private Integer soldQuantity;
    private Integer usedQuantity;
}


package com.oshayer.event_manager.events.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.*;
import java.math.BigDecimal;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class UpdateEventRequest {
    // Identity & schedule
    private String typeCode;
    private String typeName;
    private String eventCode;   // unique if provided
    private String eventName;

    private ZonedDateTime eventStart;
    private ZonedDateTime eventEnd;

    // Venue & layout
    private UUID venueId;
    private UUID seatLayoutId;

    // Staffing
    private UUID eventManager;
    private UUID eventOperator1;
    private UUID eventOperator2;
    private UUID eventChecker1;
    private UUID eventChecker2;

    private List<UUID> organizerIds;
    private List<String> imageUrls;

    private List<UpdateEventTicketTierRequest> ticketTiers;

    // Replace associations if present (null = don’t touch, empty list = clear)
    private List<UUID> artistIds;
    private List<UUID> sponsorIds;

}


package com.oshayer.event_manager.events.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class UpdateEventTicketTierRequest {
    private UUID id; // ID is needed to identify which tier to update
    private String tierCode;
    private String tierName;
    @PositiveOrZero private Integer totalQuantity;
    @DecimalMin(value = "0.0", inclusive = true) private BigDecimal price;
}

package com.oshayer.event_manager.ticketing.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class HoldConvertRequest {
    @NotNull private UUID holdId;
    @NotNull private UUID paymentId;
}


package com.oshayer.event_manager.ticketing.dto;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class HoldCreateRequest {
    @NotNull private UUID eventId;
    private UUID buyerId; // nullable = guest allowed

    @NotEmpty
    private List<UUID> seatIds; // The specific seats to be held

    @Future @NotNull private OffsetDateTime expiresAt;
}

package com.oshayer.event_manager.ticketing.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class HoldReleaseRequest {
    @NotNull private UUID holdId;
    private String reason;
}


package com.oshayer.event_manager.ticketing.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class HoldResponse {
    private UUID id;
    private UUID eventId;
    private UUID buyerId;
    private String status;
    private List<HeldSeatInfo> heldSeats;
    private OffsetDateTime expiresAt;
    private UUID finalizedPaymentId;
    private OffsetDateTime createdAt;
    private OffsetDateTime updatedAt;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class HeldSeatInfo {
        private UUID seatId;
        private String seatLabel;
        private String tierCode;
    }
}


package com.oshayer.event_manager.ticketing.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TicketCheckInRequest {
    @NotNull private UUID checkerId;
    private String gate;
}


package com.oshayer.event_manager.ticketing.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TicketCreateRequest {
    @NotNull private UUID eventId;
    @NotNull private UUID seatId; // The ID of the desired SeatEntity
    @NotNull private UUID buyerId;

    // Optional reservation time for pending tickets
    private OffsetDateTime reservedUntil;

    // Optional holder info if different from buyer
    private String holderName;
    @Email private String holderEmail;
}

package com.oshayer.event_manager.ticketing.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TicketRefundRequest {
    @NotNull @DecimalMin("0.00")
    private BigDecimal refundAmount;
}

package com.oshayer.event_manager.ticketing.dto;

import lombok.*;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TicketResponse {
    private UUID id;
    private String status;

    // Flattened from related entities for convenience
    private UUID eventId;
    private UUID buyerId;
    private UUID seatId;
    private String seatLabel;
    private String tierCode;
    private BigDecimal price;

    // Verification and Holder Info
    private String qrCode;
    private String verificationCode;
    private String holderName;
    private String holderEmail;

    // Check-in Info
    private String gate;
    private UUID checkerId;
    private OffsetDateTime checkedInAt;

    // Lifecycle Timestamps
    private OffsetDateTime reservedUntil;
    private OffsetDateTime issuedAt;

    // Refund Info
    private BigDecimal refundAmount;
    private OffsetDateTime refundedAt;

    // Audit Timestamps
    private OffsetDateTime createdAt;
    private OffsetDateTime updatedAt;
}



package com.oshayer.event_manager.users.entity;

public enum EnumUserRole {
    ROLE_USER("801", "User"),
    ROLE_ORG_ADMIN("802", "Organization Admin"),
    ROLE_EVENT_MANAGER("803", "Event Manager"),
    ROLE_OPERATOR("804", "Operator"),
    ROLE_EVENT_CHECKER("805", "Event Checker"); // ✅ new role added

    private final String code;
    private final String displayName;

    EnumUserRole(String code, String displayName) {
        this.code = code;
        this.displayName = displayName;
    }

    public String getCode() {
        return code;
    }

    public String getDisplayName() {
        return displayName;
    }

    public static EnumUserRole fromCode(String code) {
        for (EnumUserRole role : EnumUserRole.values()) {
            if (role.code.equals(code)) {
                return role;
            }
        }
        throw new IllegalArgumentException("Unknown role code: " + code);
    }
}



package com.oshayer.event_manager.events.entity;

import com.oshayer.event_manager.seat.entity.SeatEntity;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(
        name = "event_seats",
        // This constraint is the core of the design: a seat can only appear once per event.
        uniqueConstraints = {
                @UniqueConstraint(name = "uk_event_seat", columnNames = {"event_id", "seat_id"})
        },
        indexes = {
                @Index(name = "idx_event_seat_status", columnList = "status")
        }
)
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EventSeatEntity {

    @Id
    @GeneratedValue
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "event_id", nullable = false)
    private EventEntity event;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "seat_id", nullable = false)
    private SeatEntity seat;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private EventSeatStatus status = EventSeatStatus.AVAILABLE;

    @Column(name = "tier_code", nullable = false, length = 20)
    private String tierCode; // e.g., VIP, GOLD. Set when generating the inventory.

    @Column(precision = 12, scale = 2)
    private BigDecimal price;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private OffsetDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;

    public enum EventSeatStatus {
        AVAILABLE,
        RESERVED, // Temporarily held (e.g., in a user's cart)
        SOLD
    }
}


package com.oshayer.event_manager.ticketing.entity;

import com.oshayer.event_manager.events.entity.EventSeatEntity;
import com.oshayer.event_manager.users.entity.UserEntity;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.UUID;

@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
@Entity
@Table(
        name = "tickets",
        uniqueConstraints = {
                @UniqueConstraint(name = "uk_ticket_qr_code", columnNames = "qr_code")
                // The OneToOne relationship to event_seat_id now guarantees uniqueness per seat per event.
        },
        indexes = {
                @Index(name = "idx_ticket_buyer", columnList = "buyer_id"),
                @Index(name = "idx_ticket_status", columnList = "status")
        }
)
public class TicketEntity {

    @Id @GeneratedValue private UUID id;

    // This is the core link. A ticket IS the sale of a specific EventSeat.
    // The unique=true constraint on JoinColumn enforces the OneToOne relationship at the DB level.
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "event_seat_id", nullable = false, unique = true)
    private EventSeatEntity eventSeat;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "buyer_id", nullable = false)
    private UserEntity buyer;

    // lifecycle
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private TicketStatus status = TicketStatus.PENDING;

    @Column(name = "reserved_until") private OffsetDateTime reservedUntil;
    @Column(name = "issued_at") private OffsetDateTime issuedAt;
    @Column(name = "checked_in_at") private OffsetDateTime checkedInAt;

    // verification
    @Column(name = "qr_code", nullable = false, unique = true, length = 256)
    private String qrCode;
    @Column(name = "verification_code", length = 32)
    private String verificationCode;

    // holder / staff
    @Column(name = "holder_name") private String holderName;
    @Column(name = "holder_email") private String holderEmail;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "checker_id")
    private UserEntity checker;

    @Column(name = "gate") private String gate;

    // refunds
    @Column(name = "refund_amount", precision = 12, scale = 2)
    private BigDecimal refundAmount;
    @Column(name = "refunded_at")
    private OffsetDateTime refundedAt;

    // audit / concurrency
    @CreationTimestamp @Column(name = "created_at", nullable = false, updatable = false)
    private OffsetDateTime createdAt;
    @UpdateTimestamp @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;
    @Version @Column(nullable = false) private Long version = 0L;

    // Note: The buggy `setRefunedAt` method has been removed.

    public enum TicketStatus { PENDING, ISSUED, USED, CANCELED, EXPIRED, REFUNDED }
}
